// Source code is unavailable, and was generated by the Fernflower decompiler.
package com.shakeToPay.examples.clients.testClient.integrations.ws;

import com.shakeToPay.examples.clients.testClient.handler.WebsocketDataHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import java.net.URISyntaxException;
import java.util.Objects;

@Component
public class WebsocketConnector implements DisposableBean {
    private static final Logger LOGGER = LoggerFactory.getLogger(WebsocketConnector.class);
    private static final String URL_PATH_DELIMETER = "/";
    private final WebsocketClient wsClient;
    private final Monitor monitor;

    @Autowired
    WebsocketConnector(@Value("${MONO_URL}") String url, @Value("${RESTO_ID}") String user, @Value("${SECRET_KEY}") String pass, @Value("${reconnect.timeout:15000}") int reConnectTimeout, WebsocketDataHandler dataHandler) throws URISyntaxException {
        StringBuilder fullUrlContainer = new StringBuilder("wss://" + url);
        if (!StringUtils.endsWithIgnoreCase(url, "/")) {
            fullUrlContainer.append("/");
        }

        fullUrlContainer.append("restaurantEntryPoint");
        String var10003 = fullUrlContainer.toString();
        Objects.requireNonNull(dataHandler);
        this.wsClient = new WebsocketClient(var10003, user, pass, dataHandler::update);
        this.monitor = new Monitor(reConnectTimeout, user);
        this.monitor.setRunning(true);
        Thread monitorThread = new Thread(this.monitor, "WebsocketConnect-monitor-" + user);
        monitorThread.setDaemon(true);
        monitorThread.start();
    }

    public void destroy() throws Exception {
        if (this.wsClient != null) {
            this.wsClient.close();
        }

        if (this.monitor != null) {
            this.monitor.setRunning(false);
        }
    }

    class Monitor implements Runnable {
        private final Object lock;
        private boolean running;
        private final int reConnectTimeout;
        private final String user;

        public Monitor(int reConnectTimeout, String user) {
            this.lock = new Object();
            this.reConnectTimeout = reConnectTimeout;
            this.user = user;
        }

        public void run() {
            while (this.running) {
                try {
                    if (wsClient.isConnected()) {
                        WebsocketConnector.LOGGER.info("connected :)");
                        wsClient.sendMessage("Resto " + this.user + " ping", false);
                    } else {
                        synchronized (this.lock) {
                            if (!wsClient.isConnected()) {
                                WebsocketConnector.LOGGER.info("try connect ====>>>>> :(");
                                wsClient.connect();
                                WebsocketConnector.LOGGER.info("connected :)");
                            }
                        }
                    }
                } catch (Exception var5) {
                    LOGGER.error("catch problems in socketMonitor: ", var5);
                }

                try {
                    Thread.sleep((long) this.reConnectTimeout);
                } catch (InterruptedException var3) {
                    LOGGER.warn("Interrupted!", var3);
                    Thread.currentThread().interrupt();
                }
            }

        }

        void setRunning(boolean running) {
            this.running = running;
        }
    }

}
